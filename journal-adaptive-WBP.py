import numpy as np


############## functions #############

def circular_shift_identity(N, e):
    """
    Returns the circular right-shift of the identity matrix I_N by e positions.

    Parameters:
    - N (int): The size of the identity matrix. Must be an integer ≥ 2.
    - e (int): The number of positions to circularly right-shift (0 ≤ e ≤ N - 1).

    Returns:
    - numpy.ndarray: The circulant permutation matrix (CPM), obtained by circularly right-shifting every row of the identity matrix of size N x N by e positions.
    """

    if not isinstance(N, int) or N < 2:
        raise ValueError(f"N={N} is provide,  it must be an integer ≥ 2.")
    if not (np.issubdtype(type(e), np.integer)) or e < 0 or e > N - 1:
        raise ValueError(f"e = {e} and N = {N} is provided,  but e must be an integer satisfying 0 ≤ e ≤ N - 1.")

    I = np.eye(N, dtype=int)

    # Circularly shift every row of the identity matrix to the right by e positions
    CPM = np.roll(I, shift=e, axis=1)

    return CPM


######

def PCM_QCLDPC(E, N):
    """
    Constructs a parity check matrix H from an exponent matrix E and lifting factor N.

    Rules:
    - Entry -1 in E → N x N all-zero matrix
    - Entry e in E taking values in {0, ..., N-1} → circularly right-shifted identity matrix by e positions

    Parameters:
    - E (2D list or numpy.ndarray): Exponent matrix with values in {-1, 0, ..., M-1}, for some M
    - N (int): Lifting factor (N ≥ 1)

    Returns:
    - numpy.ndarray: Parity-check matrix H of shape (N * rows(E), N * cols(E))
    """

    if not isinstance(N, int) or N < 1:
        raise ValueError("N must be an integer ≥ 1.")

    E = np.array(E)
    M = E.max() + 1

    if not np.issubdtype(E.dtype, np.integer) or not np.all(E >= -1):
        raise ValueError("All entries in E must be integers ≥ -1.")


    H_rows = []
    for row in E:
        block_row = []
        for e in row:
            if e == -1:
                block = np.zeros((N, N), dtype=int)
            else:
                block = circular_shift_identity(N, e)
            block_row.append(block)
        H_rows.append(np.hstack(block_row))  # Concatenate horizontally

    H = np.vstack(H_rows)  # Concatenate rows vertically
    
    return H

##################### Codes' parameters ############################


C2 = {
    "lambda": 4,
    "omega": 8,
    "M": 403,
    "Lambda": "x**3",
    "Upsilon": "x**7",
    "P": np.array([
        [345, 152,  72, 376, 377, 197,   4, 144],
        [187, 398, 320, 225, 330, 198,  79, 289],
        [271, 165, 259, 105, 288, 254,  51, 236],
        [111, 233, 380, 332,  47,  76, 222, 247]
    ])
}

H2 = PCM_QCLDPC(C2['P'], C2['M'])

######

C3 = {
    "lambda": 5,
    "omega": 16,
    "M": 251,
    "Lambda": "x**4",
    "Upsilon": "x**15",
    "P": np.array([
        [6,   98, 208, 177,  76,  76,  76,  48, 111,  76,  76,  34,  76,  76,  64,  85],
        [198, 42, 155, 127,  29,  32,  35,  10,  76,  44,  47,   8,  53,  56,  47,  71],
        [31, 211, 158,   0, 238, 111, 199,   8, 195, 248, 121, 167,  46, 170, 246, 140],
        [117,  51,   3,  65,  57, 150, 243,  57, 213,  20, 113, 164,  48, 141, 222,  85],
        [181, 142, 121, 210, 229,  98, 218,  59, 242,  76, 196,  23, 185,  54, 162,  52]
    ])
}

H3 = PCM_QCLDPC(C3['P'], C3['M'])

######

C6 = {
    "lambda": 7,
    "omega": 42,
    "M": 25,
    "Lambda": "0.714*x**2 + 0.286*x**3",
    "Upsilon": "0.857*x**18 + 0.143*x**23",
    "P": np.array([
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 3, 8, 18, 7, 17, 22, 24, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, 19, 4, -1, -1, 22, -1, 8, -1, -1, 5, -1, -1, 9, 0, 14, -1, 15],
        [3, 12, 7, 11, 14, 18, 13, 22, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, 15, -1, -1, 3, -1, 18, -1, -1, -1, 9, 8, -1, -1, 19, 9, 20, -1, 21, 5, -1],
        [13, -1, -1, -1, -1, -1, -1, -1, 2, 6, 16, 11, 14, 9, 19, 23, 12, -1, -1, -1, -1, -1, -1, -1, 20, -1, 19, -1, -1, -1, 17, -1, -1, -1, 8, 16, 18, 4, 3, -1, 17, -1],
        [-1, -1, 15, -1, -1, -1, -1, -1, 6, 24, 14, 22, 3, 11, 1, 19, -1, -1, 13, -1, -1, -1, -1, -1, 18, -1, 18, -1, 15, -1, -1, -1, -1, 13, 11, 19, -1, -1, 20, 17, -1, 21],
        [-1, -1, -1, -1, 17, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, 3, 9, 24, 4, 21, 1, 16, 22, 14, -1, -1, 14, 23, 24, 11, -1, 16, 23, -1, -1, -1, -1, -1, -1, 7, 23],
        [-1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, 15, -1, -1, -1, -1, 9, 11, 21, 8, 17, 4, 14, 16, -1, 11, -1, 6, 11, 13, 13, 20, 6, 13, -1, -1, 16, -1, -1, -1, -1, -1]
    ])
}

H6 = PCM_QCLDPC(C6['P'], C6['M'])

######

C7 = {
    "lambda": 8,
    "omega": 42,
    "M": 25,
    "Lambda": "0.596*x**2 + 0.404*x**3",
    "Upsilon": "0.125*x**9 + 0.125*x**16 + 0.5*x**17 + 0.125*x**19 + 0.125*x**23",
    "P": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 3, 8, 18, 7, 17, 22, 24, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, 20, -1, 16, -1, -1, -1, -1, 4, -1, 10, -1, -1, 20, 19, -1, 2, 9],
        [3, 12, 7, 11, 14, 18, 13, 22, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, 22, 6, -1, -1, 13, -1, 21, 4, -1, -1, -1, -1, 14, 1, 17],
        [13, -1, -1, -1, -1, -1, -1, -1, 2, 6, 16, 11, 14, 9, 19, 23, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, 3, -1, 10, -1, 23, -1, -1, 8, 4, -1, 2, -1],
        [-1, -1, -1, 15, -1, -1, -1, -1, -1, 6, 24, 14, 22, 3, 11, 1, 19, -1, -1, 13, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, 13, -1, -1, -1, -1, 0, 3, 3, -1, 12, 3, 7],
        [-1, -1, -1, -1, -1, 17, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, 3, 9, 24, 4, 21, 1, 16, 22, -1, -1, 12, -1, 6, -1, -1, 6, -1, -1, -1, -1, 0, 6, 18, 19, -1],
        [6, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, 15, -1, -1, -1, -1, 9, 11, 21, 8, 17, 4, 14, 16, 23, 1, 3, -1, 24, 10, 0, -1, -1, 23, -1, 0, -1, -1, -1, 23, -1],
        [19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 20, -1, -1, 7, 10, 24, 21, 10, -1, 11, 22, -1, -1, -1]
    ]
}

H7 = PCM_QCLDPC(C7['P'], C7['M'])

######


C8 = {
    "lambda": 6,
    "omega": 60,
    "M": 71,
    "Lambda": "0.1*x + 0.634*x**2 + 0.266*x**3",
    "Upsilon": "0.166*x**27 + 0.668*x**30 + 0.166*x**37",
    "P": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, 20, 60, 24, 37, -1, 1, 17],
        [45, 52, 57, 62, 63, 68, 70, 54, 26, 19, 14, 9, 8, 3, 0, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, -1, 34, 51, -1, -1, 59, -1, 18, -1, -1, -1, 61, -1, 52, 46, 21, 48, -1, -1, 44, 34, -1, 2, 48, 6],
        [1, 17, 40, 29, 11, 67, 23, 65, 70, 54, 31, 42, 60, 4, -1, 0, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, 21, -1, 23, -1, -1, 7, -1, -1, 53, -1, -1, 62, -1, 32, 27, 27, 39, 1, -1, 15, -1, 16, 0, -1],
        [-1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, 3, 51, 64, 14, 29, 44, 47, 62, 68, 20, 7, 57, 42, 27, 24, 9, -1, -1, -1, 32, 29, -1, -1, -1, -1, 38, -1, 34, -1, 45, -1, 67, -1, -1, 60, 40, -1, 37, -1, 9, 20, -1, 69, 20, -1],
        [0, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 18, 3, 51, 49, 16, 33, 59, 69, 53, 68, 20, 22, 55, 38, 12, -1, -1, 62, -1, -1, -1, -1, 48, 0, 37, 48, -1, 26, 19, 59, 60, 49, 38, -1, -1, -1, -1, 67, -1, -1, -1, 24, -1, -1],
        [-1, 0, 1, 40, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 67, 14, 48, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, 67, 16, 41, 64, 0, 68, 66, 50, 20, 63, 67, 34, 45, 0, 7, 29, 11, 11, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1]
    ]
}

H8 = PCM_QCLDPC(C8['P'], C8['M'])

######

C10 = {
    "lambda": 4,
    "omega": 50,
    "M": 80,
    "Lambda": "0.02 + 0.18*x + 0.64*x**2 + 0.16*x**3",
    "Upsilon": "0.25*x**29 + 0.25*x**33 + 0.25*x**34 + 0.25*x**47",
    "P": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1],
        [1, 2, 8, -1, 53, 70, -1, 78, 72, -1, 27, -1, 3, 6, -1, -1, 79, 50, 77, -1, -1, -1, -1, 30, 7, 14, -1, -1, 51, -1, 73, 66, -1, -1, 29, -1, 18, 36, 64, -1, 74, -1, 62, 44, 16, 60, -1, 20, 37, -1],
        [3, 67, 78, 41, 31, 26, 77, 13, -1, 39, 49, 54, 9, -1, -1, 43, -1, -1, 71, -1, 6, 37, -1, -1, 21, 69, 66, 47, 57, 22, 59, 11, 14, 33, 23, 58, -1, -1, 44, 18, -1, 68, -1, -1, 36, 62, -1, 12, -1, 79],
        [42, -1, -1, 23, -1, -1, 38, 79, -1, 57, -1, -1, -1, 3, 70, 69, 54, -1, -1, 77, 10, 11, 26, 68, -1, 7, 30, 1, -1, 28, -1, 73, 50, -1, -1, 52, 36, 18, 20, 14, 4, 72, 44, 62, 60, 66, 76, 8, 34, -1]
    ]
}


H10 = PCM_QCLDPC(C10['P'], C10['M'])


######

C11 = {
    "lambda": 2,
    "omega": 25,
    "M": 32,
    "Lambda": "x",
    "Upsilon": "x**24",
    "P": [
        [(0, 17), -1, (0, 20), -1, (0, 21), -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [-1, (0, 17), -1, (0, 20), -1, (0, 21), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 25, 26, 27, 28, 29, 30, 31]
    ]
}

######


C12 = {
    "lambda": 1,
    "omega": 23,
    "M": 160,
    "Lambda": "0.480*x + 0.130*x**2 + 0.217*x**3 + 0.130*x**4 + 0.043*x**5",
    "Upsilon": "x**71",
    "P": [[
        (1,151,151,55,127,151), (138,27,139,144), (88,57,-1), (111,-1,47), (130,15,33), (11,47,118,15,108),
        (109,5,-1), (143,-1,140), (100,14,14,141,-1), (12,-1,20), (91,42,96), (74,-1,72),
        (54,29,155,157,159), (83,82,-1), (0,77,141,78,13), (112,-1,59), (119,74,56),
        (48,6,55,157,-1), (85,-1,9), (41,80,121,2,-1), (103,-1,45), (60,117,52,87), (99,148,-1)
    ]],
    "m_s": 2,
    "B_bar": [[
        (0,0,1,2,2,2), (0,1,1,2), (0,1,-1), (0,-1,2), (0,1,2), (0,0,0,1,2), (0,1,-1), (0,-1,2),
        (0,1,1,1,-1), (0,-1,2), (0,1,2), (0,-1,2), (0,1,2,2,2), (0,1,-1), (0,0,0,1,2),
        (0,-1,2), (0,1,2), (0,1,1,1,-1), (0,-1,2), (0,0,0,1,-1), (0,-1,2), (0,1,2,2), (0,1,-1)
    ]]
}

